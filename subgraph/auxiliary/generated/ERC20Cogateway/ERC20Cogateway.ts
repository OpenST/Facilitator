// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  EthereumCall,
  EthereumEvent,
  SmartContract,
  EthereumValue,
  JSONValue,
  TypedMap,
  Entity,
  EthereumTuple,
  Bytes,
  Address,
  BigInt,
  CallResult
} from "@graphprotocol/graph-ts";

export class DepositIntentConfirmed extends EthereumEvent {
  get params(): DepositIntentConfirmed__Params {
    return new DepositIntentConfirmed__Params(this);
  }
}

export class DepositIntentConfirmed__Params {
  _event: DepositIntentConfirmed;

  constructor(event: DepositIntentConfirmed) {
    this._event = event;
  }

  get messageHash(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }
}

export class GatewayProven extends EthereumEvent {
  get params(): GatewayProven__Params {
    return new GatewayProven__Params(this);
  }
}

export class GatewayProven__Params {
  _event: GatewayProven;

  constructor(event: GatewayProven) {
    this._event = event;
  }

  get remoteGateway(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get blockNumber(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class ProxyCreation extends EthereumEvent {
  get params(): ProxyCreation__Params {
    return new ProxyCreation__Params(this);
  }
}

export class ProxyCreation__Params {
  _event: ProxyCreation;

  constructor(event: ProxyCreation) {
    this._event = event;
  }

  get proxy(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class UtilityTokenCreated extends EthereumEvent {
  get params(): UtilityTokenCreated__Params {
    return new UtilityTokenCreated__Params(this);
  }
}

export class UtilityTokenCreated__Params {
  _event: UtilityTokenCreated;

  constructor(event: UtilityTokenCreated) {
    this._event = event;
  }

  get valueToken(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get utilityToken(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class WithdrawIntentDeclared extends EthereumEvent {
  get params(): WithdrawIntentDeclared__Params {
    return new WithdrawIntentDeclared__Params(this);
  }
}

export class WithdrawIntentDeclared__Params {
  _event: WithdrawIntentDeclared;

  constructor(event: WithdrawIntentDeclared) {
    this._event = event;
  }

  get amount(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get nonce(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get beneficiary(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get feeGasPrice(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get feeGasLimit(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get withdrawer(): Address {
    return this._event.parameters[5].value.toAddress();
  }

  get utilityToken(): Address {
    return this._event.parameters[6].value.toAddress();
  }

  get messageHash(): Bytes {
    return this._event.parameters[7].value.toBytes();
  }
}

export class ERC20Cogateway extends SmartContract {
  static bind(address: Address): ERC20Cogateway {
    return new ERC20Cogateway("ERC20Cogateway", address);
  }

  DEPOSIT_INTENT_TYPEHASH(): Bytes {
    let result = super.call("DEPOSIT_INTENT_TYPEHASH", []);

    return result[0].toBytes();
  }

  try_DEPOSIT_INTENT_TYPEHASH(): CallResult<Bytes> {
    let result = super.tryCall("DEPOSIT_INTENT_TYPEHASH", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  DOMAIN_SEPARATOR_VERSION(): string {
    let result = super.call("DOMAIN_SEPARATOR_VERSION", []);

    return result[0].toString();
  }

  try_DOMAIN_SEPARATOR_VERSION(): CallResult<string> {
    let result = super.tryCall("DOMAIN_SEPARATOR_VERSION", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toString());
  }

  INBOX_OFFSET(): i32 {
    let result = super.call("INBOX_OFFSET", []);

    return result[0].toI32();
  }

  try_INBOX_OFFSET(): CallResult<i32> {
    let result = super.tryCall("INBOX_OFFSET", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toI32());
  }

  MESSAGE_TYPEHASH(): Bytes {
    let result = super.call("MESSAGE_TYPEHASH", []);

    return result[0].toBytes();
  }

  try_MESSAGE_TYPEHASH(): CallResult<Bytes> {
    let result = super.tryCall("MESSAGE_TYPEHASH", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  MMB_CHANNEL_TYPEHASH(): Bytes {
    let result = super.call("MMB_CHANNEL_TYPEHASH", []);

    return result[0].toBytes();
  }

  try_MMB_CHANNEL_TYPEHASH(): CallResult<Bytes> {
    let result = super.tryCall("MMB_CHANNEL_TYPEHASH", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  MMB_DOMAIN_SEPARATOR_NAME(): string {
    let result = super.call("MMB_DOMAIN_SEPARATOR_NAME", []);

    return result[0].toString();
  }

  try_MMB_DOMAIN_SEPARATOR_NAME(): CallResult<string> {
    let result = super.tryCall("MMB_DOMAIN_SEPARATOR_NAME", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toString());
  }

  MMB_DOMAIN_SEPARATOR_TYPEHASH(): Bytes {
    let result = super.call("MMB_DOMAIN_SEPARATOR_TYPEHASH", []);

    return result[0].toBytes();
  }

  try_MMB_DOMAIN_SEPARATOR_TYPEHASH(): CallResult<Bytes> {
    let result = super.tryCall("MMB_DOMAIN_SEPARATOR_TYPEHASH", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  MMB_DOMAIN_SEPARATOR_VERSION(): string {
    let result = super.call("MMB_DOMAIN_SEPARATOR_VERSION", []);

    return result[0].toString();
  }

  try_MMB_DOMAIN_SEPARATOR_VERSION(): CallResult<string> {
    let result = super.tryCall("MMB_DOMAIN_SEPARATOR_VERSION", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toString());
  }

  OUTBOX_OFFSET(): i32 {
    let result = super.call("OUTBOX_OFFSET", []);

    return result[0].toI32();
  }

  try_OUTBOX_OFFSET(): CallResult<i32> {
    let result = super.tryCall("OUTBOX_OFFSET", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toI32());
  }

  UTILITY_TOKEN_SETUP_CALLPREFIX(): Bytes {
    let result = super.call("UTILITY_TOKEN_SETUP_CALLPREFIX", []);

    return result[0].toBytes();
  }

  try_UTILITY_TOKEN_SETUP_CALLPREFIX(): CallResult<Bytes> {
    let result = super.tryCall("UTILITY_TOKEN_SETUP_CALLPREFIX", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  WITHDRAW_INTENT_TYPEHASH(): Bytes {
    let result = super.call("WITHDRAW_INTENT_TYPEHASH", []);

    return result[0].toBytes();
  }

  try_WITHDRAW_INTENT_TYPEHASH(): CallResult<Bytes> {
    let result = super.tryCall("WITHDRAW_INTENT_TYPEHASH", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  encodedAccountPath(): Bytes {
    let result = super.call("encodedAccountPath", []);

    return result[0].toBytes();
  }

  try_encodedAccountPath(): CallResult<Bytes> {
    let result = super.tryCall("encodedAccountPath", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  genesisERC20Gateway(): Address {
    let result = super.call("genesisERC20Gateway", []);

    return result[0].toAddress();
  }

  try_genesisERC20Gateway(): CallResult<Address> {
    let result = super.tryCall("genesisERC20Gateway", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  genesisMaxStorageRootItems(): BigInt {
    let result = super.call("genesisMaxStorageRootItems", []);

    return result[0].toBigInt();
  }

  try_genesisMaxStorageRootItems(): CallResult<BigInt> {
    let result = super.tryCall("genesisMaxStorageRootItems", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  genesisMetachainId(): Bytes {
    let result = super.call("genesisMetachainId", []);

    return result[0].toBytes();
  }

  try_genesisMetachainId(): CallResult<Bytes> {
    let result = super.tryCall("genesisMetachainId", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  genesisOutboxStorageIndex(): i32 {
    let result = super.call("genesisOutboxStorageIndex", []);

    return result[0].toI32();
  }

  try_genesisOutboxStorageIndex(): CallResult<i32> {
    let result = super.tryCall("genesisOutboxStorageIndex", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toI32());
  }

  genesisStateRootProvider(): Address {
    let result = super.call("genesisStateRootProvider", []);

    return result[0].toAddress();
  }

  try_genesisStateRootProvider(): CallResult<Address> {
    let result = super.tryCall("genesisStateRootProvider", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  genesisUtilityTokenMastercopy(): Address {
    let result = super.call("genesisUtilityTokenMastercopy", []);

    return result[0].toAddress();
  }

  try_genesisUtilityTokenMastercopy(): CallResult<Address> {
    let result = super.tryCall("genesisUtilityTokenMastercopy", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  hashChannelIdentifier(
    _metachainId: Bytes,
    _outbox: Address,
    _inbox: Address
  ): Bytes {
    let result = super.call("hashChannelIdentifier", [
      EthereumValue.fromFixedBytes(_metachainId),
      EthereumValue.fromAddress(_outbox),
      EthereumValue.fromAddress(_inbox)
    ]);

    return result[0].toBytes();
  }

  try_hashChannelIdentifier(
    _metachainId: Bytes,
    _outbox: Address,
    _inbox: Address
  ): CallResult<Bytes> {
    let result = super.tryCall("hashChannelIdentifier", [
      EthereumValue.fromFixedBytes(_metachainId),
      EthereumValue.fromAddress(_outbox),
      EthereumValue.fromAddress(_inbox)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  hashDepositIntent(
    _valueToken: Address,
    _amount: BigInt,
    _beneficiary: Address
  ): Bytes {
    let result = super.call("hashDepositIntent", [
      EthereumValue.fromAddress(_valueToken),
      EthereumValue.fromUnsignedBigInt(_amount),
      EthereumValue.fromAddress(_beneficiary)
    ]);

    return result[0].toBytes();
  }

  try_hashDepositIntent(
    _valueToken: Address,
    _amount: BigInt,
    _beneficiary: Address
  ): CallResult<Bytes> {
    let result = super.tryCall("hashDepositIntent", [
      EthereumValue.fromAddress(_valueToken),
      EthereumValue.fromUnsignedBigInt(_amount),
      EthereumValue.fromAddress(_beneficiary)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  hashWithdrawIntent(
    _valueToken: Address,
    _utilityToken: Address,
    _amount: BigInt,
    _beneficiary: Address
  ): Bytes {
    let result = super.call("hashWithdrawIntent", [
      EthereumValue.fromAddress(_valueToken),
      EthereumValue.fromAddress(_utilityToken),
      EthereumValue.fromUnsignedBigInt(_amount),
      EthereumValue.fromAddress(_beneficiary)
    ]);

    return result[0].toBytes();
  }

  try_hashWithdrawIntent(
    _valueToken: Address,
    _utilityToken: Address,
    _amount: BigInt,
    _beneficiary: Address
  ): CallResult<Bytes> {
    let result = super.tryCall("hashWithdrawIntent", [
      EthereumValue.fromAddress(_valueToken),
      EthereumValue.fromAddress(_utilityToken),
      EthereumValue.fromUnsignedBigInt(_amount),
      EthereumValue.fromAddress(_beneficiary)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  inboundChannelIdentifier(): Bytes {
    let result = super.call("inboundChannelIdentifier", []);

    return result[0].toBytes();
  }

  try_inboundChannelIdentifier(): CallResult<Bytes> {
    let result = super.tryCall("inboundChannelIdentifier", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  inbox(param0: Bytes): boolean {
    let result = super.call("inbox", [EthereumValue.fromFixedBytes(param0)]);

    return result[0].toBoolean();
  }

  try_inbox(param0: Bytes): CallResult<boolean> {
    let result = super.tryCall("inbox", [EthereumValue.fromFixedBytes(param0)]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  inboxMessageHash(
    _intentHash: Bytes,
    _nonce: BigInt,
    _feeGasPrice: BigInt,
    _feeGasLimit: BigInt,
    _sender: Address
  ): Bytes {
    let result = super.call("inboxMessageHash", [
      EthereumValue.fromFixedBytes(_intentHash),
      EthereumValue.fromUnsignedBigInt(_nonce),
      EthereumValue.fromUnsignedBigInt(_feeGasPrice),
      EthereumValue.fromUnsignedBigInt(_feeGasLimit),
      EthereumValue.fromAddress(_sender)
    ]);

    return result[0].toBytes();
  }

  try_inboxMessageHash(
    _intentHash: Bytes,
    _nonce: BigInt,
    _feeGasPrice: BigInt,
    _feeGasLimit: BigInt,
    _sender: Address
  ): CallResult<Bytes> {
    let result = super.tryCall("inboxMessageHash", [
      EthereumValue.fromFixedBytes(_intentHash),
      EthereumValue.fromUnsignedBigInt(_nonce),
      EthereumValue.fromUnsignedBigInt(_feeGasPrice),
      EthereumValue.fromUnsignedBigInt(_feeGasLimit),
      EthereumValue.fromAddress(_sender)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  messageInbox(): Address {
    let result = super.call("messageInbox", []);

    return result[0].toAddress();
  }

  try_messageInbox(): CallResult<Address> {
    let result = super.tryCall("messageInbox", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  messageOutbox(): Address {
    let result = super.call("messageOutbox", []);

    return result[0].toAddress();
  }

  try_messageOutbox(): CallResult<Address> {
    let result = super.tryCall("messageOutbox", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  nonces(param0: Address): BigInt {
    let result = super.call("nonces", [EthereumValue.fromAddress(param0)]);

    return result[0].toBigInt();
  }

  try_nonces(param0: Address): CallResult<BigInt> {
    let result = super.tryCall("nonces", [EthereumValue.fromAddress(param0)]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  outboundChannelIdentifier(): Bytes {
    let result = super.call("outboundChannelIdentifier", []);

    return result[0].toBytes();
  }

  try_outboundChannelIdentifier(): CallResult<Bytes> {
    let result = super.tryCall("outboundChannelIdentifier", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  outbox(param0: Bytes): boolean {
    let result = super.call("outbox", [EthereumValue.fromFixedBytes(param0)]);

    return result[0].toBoolean();
  }

  try_outbox(param0: Bytes): CallResult<boolean> {
    let result = super.tryCall("outbox", [
      EthereumValue.fromFixedBytes(param0)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  outboxMessageHash(
    _intentHash: Bytes,
    _nonce: BigInt,
    _feeGasPrice: BigInt,
    _feeGasLimit: BigInt,
    _sender: Address
  ): Bytes {
    let result = super.call("outboxMessageHash", [
      EthereumValue.fromFixedBytes(_intentHash),
      EthereumValue.fromUnsignedBigInt(_nonce),
      EthereumValue.fromUnsignedBigInt(_feeGasPrice),
      EthereumValue.fromUnsignedBigInt(_feeGasLimit),
      EthereumValue.fromAddress(_sender)
    ]);

    return result[0].toBytes();
  }

  try_outboxMessageHash(
    _intentHash: Bytes,
    _nonce: BigInt,
    _feeGasPrice: BigInt,
    _feeGasLimit: BigInt,
    _sender: Address
  ): CallResult<Bytes> {
    let result = super.tryCall("outboxMessageHash", [
      EthereumValue.fromFixedBytes(_intentHash),
      EthereumValue.fromUnsignedBigInt(_nonce),
      EthereumValue.fromUnsignedBigInt(_feeGasPrice),
      EthereumValue.fromUnsignedBigInt(_feeGasLimit),
      EthereumValue.fromAddress(_sender)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  outboxStorageIndex(): i32 {
    let result = super.call("outboxStorageIndex", []);

    return result[0].toI32();
  }

  try_outboxStorageIndex(): CallResult<i32> {
    let result = super.tryCall("outboxStorageIndex", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toI32());
  }

  stateRootProvider(): Address {
    let result = super.call("stateRootProvider", []);

    return result[0].toAddress();
  }

  try_stateRootProvider(): CallResult<Address> {
    let result = super.tryCall("stateRootProvider", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  storageAccount(): Address {
    let result = super.call("storageAccount", []);

    return result[0].toAddress();
  }

  try_storageAccount(): CallResult<Address> {
    let result = super.tryCall("storageAccount", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  storageRoots(param0: BigInt): Bytes {
    let result = super.call("storageRoots", [
      EthereumValue.fromUnsignedBigInt(param0)
    ]);

    return result[0].toBytes();
  }

  try_storageRoots(param0: BigInt): CallResult<Bytes> {
    let result = super.tryCall("storageRoots", [
      EthereumValue.fromUnsignedBigInt(param0)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  utilityTokenMasterCopy(): Address {
    let result = super.call("utilityTokenMasterCopy", []);

    return result[0].toAddress();
  }

  try_utilityTokenMasterCopy(): CallResult<Address> {
    let result = super.tryCall("utilityTokenMasterCopy", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  utilityTokens(param0: Address): Address {
    let result = super.call("utilityTokens", [
      EthereumValue.fromAddress(param0)
    ]);

    return result[0].toAddress();
  }

  try_utilityTokens(param0: Address): CallResult<Address> {
    let result = super.tryCall("utilityTokens", [
      EthereumValue.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  valueToken(): Address {
    let result = super.call("valueToken", []);

    return result[0].toAddress();
  }

  try_valueToken(): CallResult<Address> {
    let result = super.tryCall("valueToken", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  withdraw(
    _amount: BigInt,
    _beneficiary: Address,
    _feeGasPrice: BigInt,
    _feeGasLimit: BigInt,
    _utilityToken: Address
  ): Bytes {
    let result = super.call("withdraw", [
      EthereumValue.fromUnsignedBigInt(_amount),
      EthereumValue.fromAddress(_beneficiary),
      EthereumValue.fromUnsignedBigInt(_feeGasPrice),
      EthereumValue.fromUnsignedBigInt(_feeGasLimit),
      EthereumValue.fromAddress(_utilityToken)
    ]);

    return result[0].toBytes();
  }

  try_withdraw(
    _amount: BigInt,
    _beneficiary: Address,
    _feeGasPrice: BigInt,
    _feeGasLimit: BigInt,
    _utilityToken: Address
  ): CallResult<Bytes> {
    let result = super.tryCall("withdraw", [
      EthereumValue.fromUnsignedBigInt(_amount),
      EthereumValue.fromAddress(_beneficiary),
      EthereumValue.fromUnsignedBigInt(_feeGasPrice),
      EthereumValue.fromUnsignedBigInt(_feeGasLimit),
      EthereumValue.fromAddress(_utilityToken)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  confirmDeposit(
    _valueToken: Address,
    _amount: BigInt,
    _beneficiary: Address,
    _feeGasPrice: BigInt,
    _feeGasLimit: BigInt,
    _depositor: Address,
    _blockNumber: BigInt,
    _rlpParentNodes: Bytes
  ): Bytes {
    let result = super.call("confirmDeposit", [
      EthereumValue.fromAddress(_valueToken),
      EthereumValue.fromUnsignedBigInt(_amount),
      EthereumValue.fromAddress(_beneficiary),
      EthereumValue.fromUnsignedBigInt(_feeGasPrice),
      EthereumValue.fromUnsignedBigInt(_feeGasLimit),
      EthereumValue.fromAddress(_depositor),
      EthereumValue.fromUnsignedBigInt(_blockNumber),
      EthereumValue.fromBytes(_rlpParentNodes)
    ]);

    return result[0].toBytes();
  }

  try_confirmDeposit(
    _valueToken: Address,
    _amount: BigInt,
    _beneficiary: Address,
    _feeGasPrice: BigInt,
    _feeGasLimit: BigInt,
    _depositor: Address,
    _blockNumber: BigInt,
    _rlpParentNodes: Bytes
  ): CallResult<Bytes> {
    let result = super.tryCall("confirmDeposit", [
      EthereumValue.fromAddress(_valueToken),
      EthereumValue.fromUnsignedBigInt(_amount),
      EthereumValue.fromAddress(_beneficiary),
      EthereumValue.fromUnsignedBigInt(_feeGasPrice),
      EthereumValue.fromUnsignedBigInt(_feeGasLimit),
      EthereumValue.fromAddress(_depositor),
      EthereumValue.fromUnsignedBigInt(_blockNumber),
      EthereumValue.fromBytes(_rlpParentNodes)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }
}

export class SetupCall extends EthereumCall {
  get inputs(): SetupCall__Inputs {
    return new SetupCall__Inputs(this);
  }

  get outputs(): SetupCall__Outputs {
    return new SetupCall__Outputs(this);
  }
}

export class SetupCall__Inputs {
  _call: SetupCall;

  constructor(call: SetupCall) {
    this._call = call;
  }
}

export class SetupCall__Outputs {
  _call: SetupCall;

  constructor(call: SetupCall) {
    this._call = call;
  }
}

export class ProveGatewayCall extends EthereumCall {
  get inputs(): ProveGatewayCall__Inputs {
    return new ProveGatewayCall__Inputs(this);
  }

  get outputs(): ProveGatewayCall__Outputs {
    return new ProveGatewayCall__Outputs(this);
  }
}

export class ProveGatewayCall__Inputs {
  _call: ProveGatewayCall;

  constructor(call: ProveGatewayCall) {
    this._call = call;
  }

  get _blockNumber(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _rlpAccount(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get _rlpParentNodes(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }
}

export class ProveGatewayCall__Outputs {
  _call: ProveGatewayCall;

  constructor(call: ProveGatewayCall) {
    this._call = call;
  }
}

export class WithdrawCall extends EthereumCall {
  get inputs(): WithdrawCall__Inputs {
    return new WithdrawCall__Inputs(this);
  }

  get outputs(): WithdrawCall__Outputs {
    return new WithdrawCall__Outputs(this);
  }
}

export class WithdrawCall__Inputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }

  get _amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _beneficiary(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _feeGasPrice(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get _feeGasLimit(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get _utilityToken(): Address {
    return this._call.inputValues[4].value.toAddress();
  }
}

export class WithdrawCall__Outputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }

  get messageHash_(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class ConfirmDepositCall extends EthereumCall {
  get inputs(): ConfirmDepositCall__Inputs {
    return new ConfirmDepositCall__Inputs(this);
  }

  get outputs(): ConfirmDepositCall__Outputs {
    return new ConfirmDepositCall__Outputs(this);
  }
}

export class ConfirmDepositCall__Inputs {
  _call: ConfirmDepositCall;

  constructor(call: ConfirmDepositCall) {
    this._call = call;
  }

  get _valueToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _beneficiary(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _feeGasPrice(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get _feeGasLimit(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get _depositor(): Address {
    return this._call.inputValues[5].value.toAddress();
  }

  get _blockNumber(): BigInt {
    return this._call.inputValues[6].value.toBigInt();
  }

  get _rlpParentNodes(): Bytes {
    return this._call.inputValues[7].value.toBytes();
  }
}

export class ConfirmDepositCall__Outputs {
  _call: ConfirmDepositCall;

  constructor(call: ConfirmDepositCall) {
    this._call = call;
  }

  get messageHash_(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}
