// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  EthereumCall,
  EthereumEvent,
  SmartContract,
  EthereumValue,
  JSONValue,
  TypedMap,
  Entity,
  EthereumTuple,
  Bytes,
  Address,
  BigInt,
  CallResult
} from "@graphprotocol/graph-ts";

export class DepositIntentDeclared extends EthereumEvent {
  get params(): DepositIntentDeclared__Params {
    return new DepositIntentDeclared__Params(this);
  }
}

export class DepositIntentDeclared__Params {
  _event: DepositIntentDeclared;

  constructor(event: DepositIntentDeclared) {
    this._event = event;
  }

  get amount(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get nonce(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get beneficiary(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get feeGasPrice(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get feeGasLimit(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get depositor(): Address {
    return this._event.parameters[5].value.toAddress();
  }

  get valueToken(): Address {
    return this._event.parameters[6].value.toAddress();
  }

  get messageHash(): Bytes {
    return this._event.parameters[7].value.toBytes();
  }
}

export class GatewayProven extends EthereumEvent {
  get params(): GatewayProven__Params {
    return new GatewayProven__Params(this);
  }
}

export class GatewayProven__Params {
  _event: GatewayProven;

  constructor(event: GatewayProven) {
    this._event = event;
  }

  get remoteGateway(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get blockNumber(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class WithdrawIntentConfirmed extends EthereumEvent {
  get params(): WithdrawIntentConfirmed__Params {
    return new WithdrawIntentConfirmed__Params(this);
  }
}

export class WithdrawIntentConfirmed__Params {
  _event: WithdrawIntentConfirmed;

  constructor(event: WithdrawIntentConfirmed) {
    this._event = event;
  }

  get messageHash(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }
}

export class ERC20Gateway extends SmartContract {
  static bind(address: Address): ERC20Gateway {
    return new ERC20Gateway("ERC20Gateway", address);
  }

  DEPOSIT_INTENT_TYPEHASH(): Bytes {
    let result = super.call("DEPOSIT_INTENT_TYPEHASH", []);

    return result[0].toBytes();
  }

  try_DEPOSIT_INTENT_TYPEHASH(): CallResult<Bytes> {
    let result = super.tryCall("DEPOSIT_INTENT_TYPEHASH", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  DOMAIN_SEPARATOR_VERSION(): string {
    let result = super.call("DOMAIN_SEPARATOR_VERSION", []);

    return result[0].toString();
  }

  try_DOMAIN_SEPARATOR_VERSION(): CallResult<string> {
    let result = super.tryCall("DOMAIN_SEPARATOR_VERSION", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toString());
  }

  INBOX_OFFSET(): i32 {
    let result = super.call("INBOX_OFFSET", []);

    return result[0].toI32();
  }

  try_INBOX_OFFSET(): CallResult<i32> {
    let result = super.tryCall("INBOX_OFFSET", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toI32());
  }

  MESSAGE_TYPEHASH(): Bytes {
    let result = super.call("MESSAGE_TYPEHASH", []);

    return result[0].toBytes();
  }

  try_MESSAGE_TYPEHASH(): CallResult<Bytes> {
    let result = super.tryCall("MESSAGE_TYPEHASH", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  MMB_CHANNEL_TYPEHASH(): Bytes {
    let result = super.call("MMB_CHANNEL_TYPEHASH", []);

    return result[0].toBytes();
  }

  try_MMB_CHANNEL_TYPEHASH(): CallResult<Bytes> {
    let result = super.tryCall("MMB_CHANNEL_TYPEHASH", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  MMB_DOMAIN_SEPARATOR_NAME(): string {
    let result = super.call("MMB_DOMAIN_SEPARATOR_NAME", []);

    return result[0].toString();
  }

  try_MMB_DOMAIN_SEPARATOR_NAME(): CallResult<string> {
    let result = super.tryCall("MMB_DOMAIN_SEPARATOR_NAME", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toString());
  }

  MMB_DOMAIN_SEPARATOR_TYPEHASH(): Bytes {
    let result = super.call("MMB_DOMAIN_SEPARATOR_TYPEHASH", []);

    return result[0].toBytes();
  }

  try_MMB_DOMAIN_SEPARATOR_TYPEHASH(): CallResult<Bytes> {
    let result = super.tryCall("MMB_DOMAIN_SEPARATOR_TYPEHASH", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  MMB_DOMAIN_SEPARATOR_VERSION(): string {
    let result = super.call("MMB_DOMAIN_SEPARATOR_VERSION", []);

    return result[0].toString();
  }

  try_MMB_DOMAIN_SEPARATOR_VERSION(): CallResult<string> {
    let result = super.tryCall("MMB_DOMAIN_SEPARATOR_VERSION", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toString());
  }

  OUTBOX_OFFSET(): i32 {
    let result = super.call("OUTBOX_OFFSET", []);

    return result[0].toI32();
  }

  try_OUTBOX_OFFSET(): CallResult<i32> {
    let result = super.tryCall("OUTBOX_OFFSET", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toI32());
  }

  WITHDRAW_INTENT_TYPEHASH(): Bytes {
    let result = super.call("WITHDRAW_INTENT_TYPEHASH", []);

    return result[0].toBytes();
  }

  try_WITHDRAW_INTENT_TYPEHASH(): CallResult<Bytes> {
    let result = super.tryCall("WITHDRAW_INTENT_TYPEHASH", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  encodedAccountPath(): Bytes {
    let result = super.call("encodedAccountPath", []);

    return result[0].toBytes();
  }

  try_encodedAccountPath(): CallResult<Bytes> {
    let result = super.tryCall("encodedAccountPath", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  hashChannelIdentifier(
    _metachainId: Bytes,
    _outbox: Address,
    _inbox: Address
  ): Bytes {
    let result = super.call("hashChannelIdentifier", [
      EthereumValue.fromFixedBytes(_metachainId),
      EthereumValue.fromAddress(_outbox),
      EthereumValue.fromAddress(_inbox)
    ]);

    return result[0].toBytes();
  }

  try_hashChannelIdentifier(
    _metachainId: Bytes,
    _outbox: Address,
    _inbox: Address
  ): CallResult<Bytes> {
    let result = super.tryCall("hashChannelIdentifier", [
      EthereumValue.fromFixedBytes(_metachainId),
      EthereumValue.fromAddress(_outbox),
      EthereumValue.fromAddress(_inbox)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  hashDepositIntent(
    _valueToken: Address,
    _amount: BigInt,
    _beneficiary: Address
  ): Bytes {
    let result = super.call("hashDepositIntent", [
      EthereumValue.fromAddress(_valueToken),
      EthereumValue.fromUnsignedBigInt(_amount),
      EthereumValue.fromAddress(_beneficiary)
    ]);

    return result[0].toBytes();
  }

  try_hashDepositIntent(
    _valueToken: Address,
    _amount: BigInt,
    _beneficiary: Address
  ): CallResult<Bytes> {
    let result = super.tryCall("hashDepositIntent", [
      EthereumValue.fromAddress(_valueToken),
      EthereumValue.fromUnsignedBigInt(_amount),
      EthereumValue.fromAddress(_beneficiary)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  hashWithdrawIntent(
    _valueToken: Address,
    _utilityToken: Address,
    _amount: BigInt,
    _beneficiary: Address
  ): Bytes {
    let result = super.call("hashWithdrawIntent", [
      EthereumValue.fromAddress(_valueToken),
      EthereumValue.fromAddress(_utilityToken),
      EthereumValue.fromUnsignedBigInt(_amount),
      EthereumValue.fromAddress(_beneficiary)
    ]);

    return result[0].toBytes();
  }

  try_hashWithdrawIntent(
    _valueToken: Address,
    _utilityToken: Address,
    _amount: BigInt,
    _beneficiary: Address
  ): CallResult<Bytes> {
    let result = super.tryCall("hashWithdrawIntent", [
      EthereumValue.fromAddress(_valueToken),
      EthereumValue.fromAddress(_utilityToken),
      EthereumValue.fromUnsignedBigInt(_amount),
      EthereumValue.fromAddress(_beneficiary)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  inboundChannelIdentifier(): Bytes {
    let result = super.call("inboundChannelIdentifier", []);

    return result[0].toBytes();
  }

  try_inboundChannelIdentifier(): CallResult<Bytes> {
    let result = super.tryCall("inboundChannelIdentifier", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  inbox(param0: Bytes): boolean {
    let result = super.call("inbox", [EthereumValue.fromFixedBytes(param0)]);

    return result[0].toBoolean();
  }

  try_inbox(param0: Bytes): CallResult<boolean> {
    let result = super.tryCall("inbox", [EthereumValue.fromFixedBytes(param0)]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  inboxMessageHash(
    _intentHash: Bytes,
    _nonce: BigInt,
    _feeGasPrice: BigInt,
    _feeGasLimit: BigInt,
    _sender: Address
  ): Bytes {
    let result = super.call("inboxMessageHash", [
      EthereumValue.fromFixedBytes(_intentHash),
      EthereumValue.fromUnsignedBigInt(_nonce),
      EthereumValue.fromUnsignedBigInt(_feeGasPrice),
      EthereumValue.fromUnsignedBigInt(_feeGasLimit),
      EthereumValue.fromAddress(_sender)
    ]);

    return result[0].toBytes();
  }

  try_inboxMessageHash(
    _intentHash: Bytes,
    _nonce: BigInt,
    _feeGasPrice: BigInt,
    _feeGasLimit: BigInt,
    _sender: Address
  ): CallResult<Bytes> {
    let result = super.tryCall("inboxMessageHash", [
      EthereumValue.fromFixedBytes(_intentHash),
      EthereumValue.fromUnsignedBigInt(_nonce),
      EthereumValue.fromUnsignedBigInt(_feeGasPrice),
      EthereumValue.fromUnsignedBigInt(_feeGasLimit),
      EthereumValue.fromAddress(_sender)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  messageInbox(): Address {
    let result = super.call("messageInbox", []);

    return result[0].toAddress();
  }

  try_messageInbox(): CallResult<Address> {
    let result = super.tryCall("messageInbox", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  messageOutbox(): Address {
    let result = super.call("messageOutbox", []);

    return result[0].toAddress();
  }

  try_messageOutbox(): CallResult<Address> {
    let result = super.tryCall("messageOutbox", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  nonces(param0: Address): BigInt {
    let result = super.call("nonces", [EthereumValue.fromAddress(param0)]);

    return result[0].toBigInt();
  }

  try_nonces(param0: Address): CallResult<BigInt> {
    let result = super.tryCall("nonces", [EthereumValue.fromAddress(param0)]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  outboundChannelIdentifier(): Bytes {
    let result = super.call("outboundChannelIdentifier", []);

    return result[0].toBytes();
  }

  try_outboundChannelIdentifier(): CallResult<Bytes> {
    let result = super.tryCall("outboundChannelIdentifier", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  outbox(param0: Bytes): boolean {
    let result = super.call("outbox", [EthereumValue.fromFixedBytes(param0)]);

    return result[0].toBoolean();
  }

  try_outbox(param0: Bytes): CallResult<boolean> {
    let result = super.tryCall("outbox", [
      EthereumValue.fromFixedBytes(param0)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  outboxMessageHash(
    _intentHash: Bytes,
    _nonce: BigInt,
    _feeGasPrice: BigInt,
    _feeGasLimit: BigInt,
    _sender: Address
  ): Bytes {
    let result = super.call("outboxMessageHash", [
      EthereumValue.fromFixedBytes(_intentHash),
      EthereumValue.fromUnsignedBigInt(_nonce),
      EthereumValue.fromUnsignedBigInt(_feeGasPrice),
      EthereumValue.fromUnsignedBigInt(_feeGasLimit),
      EthereumValue.fromAddress(_sender)
    ]);

    return result[0].toBytes();
  }

  try_outboxMessageHash(
    _intentHash: Bytes,
    _nonce: BigInt,
    _feeGasPrice: BigInt,
    _feeGasLimit: BigInt,
    _sender: Address
  ): CallResult<Bytes> {
    let result = super.tryCall("outboxMessageHash", [
      EthereumValue.fromFixedBytes(_intentHash),
      EthereumValue.fromUnsignedBigInt(_nonce),
      EthereumValue.fromUnsignedBigInt(_feeGasPrice),
      EthereumValue.fromUnsignedBigInt(_feeGasLimit),
      EthereumValue.fromAddress(_sender)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  outboxStorageIndex(): i32 {
    let result = super.call("outboxStorageIndex", []);

    return result[0].toI32();
  }

  try_outboxStorageIndex(): CallResult<i32> {
    let result = super.tryCall("outboxStorageIndex", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toI32());
  }

  stateRootProvider(): Address {
    let result = super.call("stateRootProvider", []);

    return result[0].toAddress();
  }

  try_stateRootProvider(): CallResult<Address> {
    let result = super.tryCall("stateRootProvider", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  storageAccount(): Address {
    let result = super.call("storageAccount", []);

    return result[0].toAddress();
  }

  try_storageAccount(): CallResult<Address> {
    let result = super.tryCall("storageAccount", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  storageRoots(param0: BigInt): Bytes {
    let result = super.call("storageRoots", [
      EthereumValue.fromUnsignedBigInt(param0)
    ]);

    return result[0].toBytes();
  }

  try_storageRoots(param0: BigInt): CallResult<Bytes> {
    let result = super.tryCall("storageRoots", [
      EthereumValue.fromUnsignedBigInt(param0)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  deposit(
    _amount: BigInt,
    _beneficiary: Address,
    _feeGasPrice: BigInt,
    _feeGasLimit: BigInt,
    _valueToken: Address
  ): Bytes {
    let result = super.call("deposit", [
      EthereumValue.fromUnsignedBigInt(_amount),
      EthereumValue.fromAddress(_beneficiary),
      EthereumValue.fromUnsignedBigInt(_feeGasPrice),
      EthereumValue.fromUnsignedBigInt(_feeGasLimit),
      EthereumValue.fromAddress(_valueToken)
    ]);

    return result[0].toBytes();
  }

  try_deposit(
    _amount: BigInt,
    _beneficiary: Address,
    _feeGasPrice: BigInt,
    _feeGasLimit: BigInt,
    _valueToken: Address
  ): CallResult<Bytes> {
    let result = super.tryCall("deposit", [
      EthereumValue.fromUnsignedBigInt(_amount),
      EthereumValue.fromAddress(_beneficiary),
      EthereumValue.fromUnsignedBigInt(_feeGasPrice),
      EthereumValue.fromUnsignedBigInt(_feeGasLimit),
      EthereumValue.fromAddress(_valueToken)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  confirmWithdraw(
    _utilityToken: Address,
    _valueToken: Address,
    _amount: BigInt,
    _beneficiary: Address,
    _feeGasPrice: BigInt,
    _feeGasLimit: BigInt,
    _withdrawer: Address,
    _blockNumber: BigInt,
    _rlpParentNodes: Bytes
  ): Bytes {
    let result = super.call("confirmWithdraw", [
      EthereumValue.fromAddress(_utilityToken),
      EthereumValue.fromAddress(_valueToken),
      EthereumValue.fromUnsignedBigInt(_amount),
      EthereumValue.fromAddress(_beneficiary),
      EthereumValue.fromUnsignedBigInt(_feeGasPrice),
      EthereumValue.fromUnsignedBigInt(_feeGasLimit),
      EthereumValue.fromAddress(_withdrawer),
      EthereumValue.fromUnsignedBigInt(_blockNumber),
      EthereumValue.fromBytes(_rlpParentNodes)
    ]);

    return result[0].toBytes();
  }

  try_confirmWithdraw(
    _utilityToken: Address,
    _valueToken: Address,
    _amount: BigInt,
    _beneficiary: Address,
    _feeGasPrice: BigInt,
    _feeGasLimit: BigInt,
    _withdrawer: Address,
    _blockNumber: BigInt,
    _rlpParentNodes: Bytes
  ): CallResult<Bytes> {
    let result = super.tryCall("confirmWithdraw", [
      EthereumValue.fromAddress(_utilityToken),
      EthereumValue.fromAddress(_valueToken),
      EthereumValue.fromUnsignedBigInt(_amount),
      EthereumValue.fromAddress(_beneficiary),
      EthereumValue.fromUnsignedBigInt(_feeGasPrice),
      EthereumValue.fromUnsignedBigInt(_feeGasLimit),
      EthereumValue.fromAddress(_withdrawer),
      EthereumValue.fromUnsignedBigInt(_blockNumber),
      EthereumValue.fromBytes(_rlpParentNodes)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }
}

export class SetupCall extends EthereumCall {
  get inputs(): SetupCall__Inputs {
    return new SetupCall__Inputs(this);
  }

  get outputs(): SetupCall__Outputs {
    return new SetupCall__Outputs(this);
  }
}

export class SetupCall__Inputs {
  _call: SetupCall;

  constructor(call: SetupCall) {
    this._call = call;
  }

  get _metachainId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get _erc20Cogateway(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _stateRootProvider(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _maxStorageRootItems(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get _outboxStorageIndex(): i32 {
    return this._call.inputValues[4].value.toI32();
  }
}

export class SetupCall__Outputs {
  _call: SetupCall;

  constructor(call: SetupCall) {
    this._call = call;
  }
}

export class ProveGatewayCall extends EthereumCall {
  get inputs(): ProveGatewayCall__Inputs {
    return new ProveGatewayCall__Inputs(this);
  }

  get outputs(): ProveGatewayCall__Outputs {
    return new ProveGatewayCall__Outputs(this);
  }
}

export class ProveGatewayCall__Inputs {
  _call: ProveGatewayCall;

  constructor(call: ProveGatewayCall) {
    this._call = call;
  }

  get _blockNumber(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _rlpAccount(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get _rlpParentNodes(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }
}

export class ProveGatewayCall__Outputs {
  _call: ProveGatewayCall;

  constructor(call: ProveGatewayCall) {
    this._call = call;
  }
}

export class DepositCall extends EthereumCall {
  get inputs(): DepositCall__Inputs {
    return new DepositCall__Inputs(this);
  }

  get outputs(): DepositCall__Outputs {
    return new DepositCall__Outputs(this);
  }
}

export class DepositCall__Inputs {
  _call: DepositCall;

  constructor(call: DepositCall) {
    this._call = call;
  }

  get _amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _beneficiary(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _feeGasPrice(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get _feeGasLimit(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get _valueToken(): Address {
    return this._call.inputValues[4].value.toAddress();
  }
}

export class DepositCall__Outputs {
  _call: DepositCall;

  constructor(call: DepositCall) {
    this._call = call;
  }

  get messageHash_(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class ConfirmWithdrawCall extends EthereumCall {
  get inputs(): ConfirmWithdrawCall__Inputs {
    return new ConfirmWithdrawCall__Inputs(this);
  }

  get outputs(): ConfirmWithdrawCall__Outputs {
    return new ConfirmWithdrawCall__Outputs(this);
  }
}

export class ConfirmWithdrawCall__Inputs {
  _call: ConfirmWithdrawCall;

  constructor(call: ConfirmWithdrawCall) {
    this._call = call;
  }

  get _utilityToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _valueToken(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get _beneficiary(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get _feeGasPrice(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get _feeGasLimit(): BigInt {
    return this._call.inputValues[5].value.toBigInt();
  }

  get _withdrawer(): Address {
    return this._call.inputValues[6].value.toAddress();
  }

  get _blockNumber(): BigInt {
    return this._call.inputValues[7].value.toBigInt();
  }

  get _rlpParentNodes(): Bytes {
    return this._call.inputValues[8].value.toBytes();
  }
}

export class ConfirmWithdrawCall__Outputs {
  _call: ConfirmWithdrawCall;

  constructor(call: ConfirmWithdrawCall) {
    this._call = call;
  }

  get messageHash_(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}
